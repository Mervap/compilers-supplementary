-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
import SMCompileExpr;
import List;
import Fun;
import Buffer;
import SM;

fun compileFunction(env, Fun (funLabel, args, body, state)) {
  case env.genLabel of
    [endLab, env] ->
      var funEnv = env.beginFun(state).addArgs(args);
      case compileExpression(endLab, funEnv, body) of
        [endLabUsed, env, code] -> [
          env,
          singletonBuffer(LABEL(funLabel))
            <+ BEGIN(funLabel, args.size, env.getLocals)
            <+> code
            <+> label(endLab, endLabUsed)
            <+ END
        ]
      esac
  esac
}

fun compileFunctions(env, funcs) {
  case funcs of
    {}            -> [env, emptyBuffer()]
    | func : tail ->
      case env.compileFunction(func) of
        [env, funCode] ->
          case env.compileFunctions(tail) of
            [env, code] -> [env, funCode <+> code]
          esac
      esac
  esac
}

fun compileAllFunctions(env) {
  case env.getFuns of
    [{}, env] -> emptyBuffer()
    | [funcs, env] ->
      case env.compileFunctions(funcs) of
        [env, code] -> code <+> env.compileAllFunctions
      esac
  esac
}

public fun compileSM(stmt) {
  case
    initCompEnv()
      .beginScope
      .addFun("read", "$read", 0)
      .addFun("write", "$write", 1)
      .addFun("length", "$length", 1)
      .genLabel
  of
    [endLab, env] ->
      case compileExpression(endLab, env, stmt) of
        [labUsed, env, code] -> getBuffer $
          LABEL("main").singletonBuffer
            <+ BEGIN("main", 0, env.getLocals)
            <+> code
            <+> label(endLab, labUsed)
            <+ END
            <+> env.compileAllFunctions
      esac
  esac
}