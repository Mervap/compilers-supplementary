-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
import List;
import Fun;
import Buffer;
import SM;

public fun label(lab, labUsed, forward) {
  if labUsed
    then singletonBuffer(LABEL(lab, forward))
    else emptyBuffer()
  fi
}

public fun compileExpression(lab, env, stmt) {
  case stmt of
    Assn  (ref, expr)   ->
      case env.genLabel of
        [refLab, env] ->
          case compileExpression(refLab, env, ref) of
            [refLabUsed, env, codeRef] ->
              case compileExpression(lab, env, expr) of
                [labUsed, env, codeExpr] -> [
                  false, env,
                  codeRef <+> label(refLab, refLabUsed, false) <+> codeExpr <+> label(lab, labUsed, false) <+
                    case ref of Ref (_) -> STI | _ -> STA esac
                ]
              esac
          esac
      esac
    | Set (ref, e) -> compileExpression(lab, env, Assn(Ref(ref), e))
    | Seq (s1, s2) ->
      case env.genLabel of
        [s2Lab, env] ->
          case compileExpression(s2Lab, env, s1) of
            [s2LabUsed, env, s1Code] ->
              case compileExpression(lab, env, s2) of
                [labUsed, env, s2Code] -> [labUsed, env, s1Code <+> label(s2Lab, s2LabUsed, false) <+> s2Code]
              esac
          esac
      esac
    | Skip       -> [false, env, emptyBuffer()]
    | Var    (x) -> [false, env, singletonBuffer(LD(env.lookupVal(x)))]
    | Ref    (x) -> [false, env, singletonBuffer(LDA(env.lookupVar(x)))]
    | Const  (n) -> [false, env, singletonBuffer(CONST(n))]
    | Binop  (opName, l, r) ->
      case compileExpression(lab, env, l) of
        [labUsed, env, codeL] ->
          case env.genLabel of
            [rLab, env] ->
              case compileExpression(rLab, env, r) of
                [rLabUsed, env, codeR] -> [
                  false, env,
                  codeL <+> label(lab, labUsed, false) <+> codeR <+> label(rLab, rLabUsed, false) <+ BINOP(opName)
                ]
              esac
          esac
      esac
    | Ignor  (e) ->
      case compileExpression(lab, env, e) of
        [labUsed, env, code] -> [false, env, code <+> label(lab, labUsed, false) <+ DROP]
      esac
    | If (condition, thenBody, elseBody) ->
      case env.genLabels(2) of
        [conditionLabel, elseLabel, env] ->
          case compileExpression(conditionLabel, env, condition) of
            [conditionLabUsed, env, conditionCode] ->
              case compileExpression(lab, env, thenBody) of
                [_, env, ifCode] ->
                  case compileExpression(lab, env, elseBody) of
                    [_, env, elseCode] -> [
                      true, env,
                      conditionCode <+> label(conditionLabel, conditionLabUsed, false) <+ CJMP("z", elseLabel) <+>
                        ifCode <+ JMP(lab) <+
                        LABEL(elseLabel, false) <+> elseCode
                    ]
                  esac
              esac
          esac
      esac
    | While (condition, body) ->
      case env.genLabels(2) of
        [conditionLabSt, conditionLabEnd, env] ->
          case compileExpression(conditionLabSt, env, body) of
            [_, env, bodyCode] ->
              case compileExpression(conditionLabEnd, env, condition) of
                [conditionLabEndUsed, env, conditionCode] -> [
                  true, env,
                  label(conditionLabSt, true, true) <+> conditionCode <+> label(conditionLabEnd, conditionLabEndUsed, false)
                    <+ CJMP("z", lab) <+> bodyCode <+ JMP(conditionLabSt)
                ]
              esac
          esac
      esac
    | DoWhile(body, condition) ->
      case env.genLabels(3) of
        [conditionLab, bodyStLabel, bodyEndLabel, env] ->
          case compileExpression(bodyEndLabel, env, body) of
            [bodyEndLabelUsed, env, bodyCode] ->
              case compileExpression(conditionLab, env, condition) of
                [conditionLabUsed, env, conditionCode] -> [
                  false, env,
                  label(bodyStLabel, true, false) <+> bodyCode <+> label(bodyEndLabel, bodyEndLabelUsed, false) <+>
                    conditionCode <+> label(conditionLab, conditionLabUsed, false) <+ CJMP("nz", bodyStLabel)
                ]
              esac
          esac
      esac
    | Scope (defs, expr) ->
      case env.beginScope.addDefs(defs) of
        [env, funcs, globals] ->
          case compileExpression(lab, env.registerFuncs(funcs), expr) of
            [labUsed, env, code] -> [labUsed, env.endScope, globals <+> code]
          esac
      esac
    | Call (name, args) ->
      case env.lookupFun(name) of
        Fun (label, argsLen) ->
          case compileExpressionList(env, args) of
            [env, code] -> [
              false,
              env,
              code <+
                if compare(substring(label, 0, 1), "$") == 0
                  then BUILTIN(substring(label, 1, length(label) - 1), argsLen)
                  else CALL(label, argsLen)
                fi
            ]
          esac
      esac
    | String (s)         -> [false, env, STRING(s).singletonBuffer]
    | Elem (arr, idx)    ->
      case compileExpressionList(env, { arr, idx }) of
        [env, code] -> [false, env, code <+ ELEM]
      esac
    | ElemRef (ref, idx) ->
      case compileExpressionList(env, { ref, idx }) of
        [env, code] -> [false, env, code]
      esac
    | Array (arr)        ->
      case compileExpressionList(env, arr) of
        [env, code] -> [false, env, singletonBuffer(CONST(size(arr))) <+> code <+ ARRAY(size(arr)) ]
      esac
    | Sexp (name, data) ->
      case compileExpressionList(env, data) of
        [env, code] -> [false, env, singletonBuffer(CONST(size(data) + 1)) <+> code <+ SEXP(name, size(data)) ]
      esac
    | Case (loc, name, branches) ->
      var v = lookupVar(env, name);
      case compileCaseBranches(env, branches, lab) of
        [env, branchesCode] ->
          [
            true,
            env,
            LD(v).singletonBuffer <+>
              branchesCode <+
              META(sprintf("Failed to match at %d:%d", loc.fst, loc.snd)) <+ DROP
          ]
      esac
  esac
}

fun dropLabel(lab, lvl) {
  if (lvl == 0) then lab else sprintf("%s_drop_%d", lab, lvl) fi
}

fun compilePattern(env, pattern, lab, lvl) {
  var failMatchLab = dropLabel(lab, lvl);
  case pattern of
      Wildcard              -> [env, emptyBuffer(), lvl]
    | Named (_, None)       -> [env, emptyBuffer(), lvl]
    | Named (_, pattern)    -> compilePattern(env, pattern, lab, lvl)
    | Const (n)             -> [env, listBuffer({ DUP, CONST(n), BINOP("=="), CJMP("z", failMatchLab) }), lvl]
    | String (s)            -> [env, listBuffer({ DUP, STRPATT(s) }), lvl]
    | Array (a)             -> compilePattern(env, Sexp(None, a), lab, lvl)
    | Sexp (name, patterns) ->
      case compilePatternList(env, patterns, lab, lvl + 1) of
        [env, patternsCode, maxLvl] -> [
          env,
          singletonBuffer(DUP) <+
            PATT(name, patterns.size) <+
            CJMP("z", failMatchLab) <+>
            patternsCode,
          maxLvl
        ]
      esac
  esac
}

fun compilePatternList(env, patternList, lab, lvl) {
  case
    foldl(
      fun ([ind, env, code, maxLvl], pattern) {
        case compilePattern(env, pattern, lab, lvl) of
          [env, patternCode, lvl] -> [
            ind + 1,
            env,
            code <+
              DUP <+ CONST(ind) <+ ELEM <+>
              patternCode <+
              DROP,
            if lvl > maxLvl then lvl else maxLvl fi
          ]
        esac
      },
      [0, env, emptyBuffer(), lvl],
      patternList
    )
  of
    [_, env, code, maxLvl] -> [env, code, maxLvl]
  esac
}

fun compileCaseBranches(env, branches, lab) {
  fun dropLabels(lab, lvl) {
    if lvl == 0
      then singletonBuffer(LABEL(lab, false))
      else singletonBuffer(LABEL(dropLabel(lab, lvl), false)) <+ DROP <+> dropLabels(lab, lvl - 1)
    fi
  }

  fun compileCaseBranch(env, [pattern, branch]) {
    case env.genLabel of
      [matchLab, env] ->
        case compilePattern(env, pattern, matchLab, 0) of
          [env, patternCode, maxLvl] ->
            case compileExpression(lab, env, branch) of
              [_, env, branchCode] -> [
                env,
                patternCode <+ DROP <+>
                  branchCode <+ JMP(lab) <+>
                  dropLabels(matchLab, maxLvl)
              ]
            esac
        esac
    esac
  }

  foldl(
    fun ([env, code], caseElem) {
      case compileCaseBranch(env, caseElem) of
        [env, branchCode] -> [env, code <+> branchCode]
      esac
    },
    [env, emptyBuffer()],
    branches
  )
}

public fun compileExpressionList(env, stmts) {
  fun compileSingle([env, code], stmt) {
    case env.genLabel of
      [endLab, env] ->
        case compileExpression(endLab, env, stmt) of
          [endLabUsed, env, exprCode] -> [env, code <+> exprCode <+> label(endLab, endLabUsed, false)]
        esac
    esac
  }

  foldl(compileSingle, [env, emptyBuffer()], stmts)
}

