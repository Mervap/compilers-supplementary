-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
import List;
import Fun;
import Buffer;
import SM;

public fun label(lab, labUsed) {
  if labUsed
    then singletonBuffer(LABEL(lab))
    else emptyBuffer()
  fi
}

public fun compileExpression(lab, env, stmt) {
  case stmt of
      Read  (x) -> [false, env, singletonBuffer(READ) <+ ST(env.lookupVar(x))]
    | Write (e) ->
      case compileExpression(lab, env, e) of
        [labUsed, env, code] -> [false, env, code <+> label(lab, labUsed) <+ WRITE]
      esac
    | Assn  (ref, expr)   ->
      case env.genLabel of
        [refLab, env] ->
          case compileExpression(refLab, env, ref) of
            [refLabUsed, env, codeRef] ->
              case compileExpression(lab, env, expr) of
                [labUsed, env, codeExpr] -> [
                  false, env,
                  codeRef <+> label(refLab, refLabUsed) <+> codeExpr <+> label(lab, labUsed) <+ STI
                ]
              esac
          esac
      esac
    | Seq   (s1, s2) ->
      case env.genLabel of
        [s2Lab, env] ->
          case compileExpression(s2Lab, env, s1) of
            [s2LabUsed, env, s1Code] ->
              case compileExpression(lab, env, s2) of
                [labUsed, env, s2Code] -> [labUsed, env, s1Code <+> label(s2Lab, s2LabUsed) <+> s2Code]
              esac
          esac
      esac
    | Skip       -> [false, env, emptyBuffer()]
    | Var    (x) -> [false, env, singletonBuffer(LD(env.lookupVar(x)))]
    | Ref    (x) -> [false, env, singletonBuffer(LDA(env.lookupVar(x)))]
    | Const  (n) -> [false, env, singletonBuffer(CONST(n))]
    | Binop  (opName, l, r) ->
      case compileExpression(lab, env, l) of
        [labUsed, env, codeL] ->
          case env.genLabel of
            [rLab, env] ->
              case compileExpression(rLab, env, r) of
                [rLabUsed, env, codeR] -> [
                  false, env,
                  codeL <+> label(lab, labUsed) <+> codeR <+> label(rLab, rLabUsed) <+ BINOP(opName)
                ]
              esac
          esac
      esac
    | Ignor  (e) ->
      case compileExpression(lab, env, e) of
        [labUsed, env, code] -> [false, env, code <+> label(lab, labUsed) <+ DROP]
      esac
    | If (condition, thenBody, elseBody) ->
      case env.genLabels(2) of
        [conditionLabel, elseLabel, env] ->
          case compileExpression(conditionLabel, env, condition) of
            [conditionLabUsed, env, conditionCode] ->
              case compileExpression(lab, env, thenBody) of
                [_, env, ifCode] ->
                  case compileExpression(lab, env, elseBody) of
                    [_, env, elseCode] -> [
                      true, env,
                      conditionCode <+> label(conditionLabel, conditionLabUsed) <+ CJMP("z", elseLabel) <+>
                        ifCode <+ JMP(lab) <+
                        LABEL(elseLabel) <+> elseCode
                    ]
                  esac
              esac
          esac
      esac
    | While (condition, body) ->
      case env.genLabels(2) of
        [conditionLabSt, conditionLabEnd, env] ->
          case compileExpression(conditionLabSt, env, body) of
            [_, env, bodyCode] ->
              case compileExpression(conditionLabEnd, env, condition) of
                [conditionLabEndUsed, env, conditionCode] -> [
                  true, env,
                  label(conditionLabSt, true) <+> conditionCode <+> label(conditionLabEnd, conditionLabEndUsed)
                    <+ CJMP("z", lab) <+> bodyCode <+ JMP(conditionLabSt)
                ]
              esac
          esac
      esac
    | DoWhile(body, condition) ->
      case env.genLabels(3) of
        [conditionLab, bodyStLabel, bodyEndLabel, env] ->
          case compileExpression(bodyEndLabel, env, body) of
            [bodyEndLabelUsed, env, bodyCode] ->
              case compileExpression(conditionLab, env, condition) of
                [conditionLabUsed, env, conditionCode] -> [
                  false, env,
                  label(bodyStLabel, true) <+> bodyCode <+> label(bodyEndLabel, bodyEndLabelUsed) <+>
                    conditionCode <+> label(conditionLab, conditionLabUsed) <+ CJMP("nz", bodyStLabel)
                ]
              esac
          esac
      esac
    | Scope (defs, expr) ->
      case env.beginScope.addDefs(defs) of
        [env, funcs, globals] ->
          case compileExpression(lab, env.registerFuncs(funcs), expr) of
            [labUsed, env, code] -> [labUsed, env.endScope, globals <+> code]
          esac
      esac
    | Call (name, args) ->
      case env.lookupFun(name) of
        Fun (label, argsLen) ->
          case env.compileExpressionList(args) of
            [env, code] -> [false, env, code <+ CALL(label, argsLen)]
          esac
      esac
  esac
}

public fun compileExpressionList(env, stmts) {
  fun compileSingle([env, code], stmt) {
    case env.genLabel of
      [endLab, env] ->
        case compileExpression(endLab, env, stmt) of
          [endLabUsed, env, exprCode] -> [env, code <+> exprCode <+> label(endLab, endLabUsed)]
        esac
    esac
  }

  foldl(compileSingle, [env, emptyBuffer()], stmts)
}

