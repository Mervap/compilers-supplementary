-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax (-l p -r)
}

var lParen = s("(");
var rParen = s(")");

-- Primary expression
var primary = memo $ eta syntax (
  x = decimal { Const(stringInt(x)) } |
  x = lident  { Var(x) }              |
  inbr[lParen, exp, rParen]
);

var exp = memo $ eta (
  fun binop(op) {
    [s(op), fun (l, op, r) { Binop(op, l, r) }]
  }

  expr(
    {
      [Left, map(binop, { "!!" })],
      [Left, map(binop, { "&&" })],
      [Nona, map(binop, { "<", "<=", ">", ">=", "==", "!=" })],
      [Left, map(binop, { "+", "-" })],
      [Left, map(binop, { "*", "/", "%" })]
    },
    primary
  )
);

var elseOrSkip = memo $ eta syntax (
  -kElse stmt_seq | empty { Skip }
);

var thenStmt = memo $ eta syntax (
  condition=exp -kThen body=stmt_seq next=elseStmt { If(condition, body, next) }
);

var elseStmt = memo $ eta syntax (
  -kElif thenStmt | elseOrSkip
);

var stmt = memo $ eta syntax (
  kSkip                                     { Skip }                         |
  kRead name=inbr[lParen, lident, rParen]   { Read(name) }                   |
  kWrite exp=inbr[lParen, exp, rParen]      { Write(exp) }                   |
  name=lident -s[":="] value=exp            { Assn(name, value) }            |
  -kIf thenStmt -kFi                                                         |
  -kWhile condition=exp -kDo body=stmt_seq -kOd { While(condition, body) }   |
  -kDo body=stmt_seq -kWhile condition=exp -kOd { DoWhile(body, condition) } |
  -kFor beforeAll=stmt_seq -s[","]
        condition=exp      -s[","]
        afterAll=stmt_seq  -kDo
    body=stmt_seq
  -kOd {
    Seq(beforeAll, While(condition, Seq(body, afterAll)))
  }
);

var stmt_seq = memo $ eta syntax (
  l = stmt_seq -s[";"] r = stmt { Seq(l, r) } |
  stmt
);

-- Public top-level parser
public parse = stmt_seq;
