-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax (-l p -r)
}

var lParen = s("(");
var rParen = s(")");

-- Primary expression
var primary = memo $ eta syntax (
  x = decimal { Const(stringInt(x)) } |
  x = lident  { Var(x) }              |
  inbr[lParen, exp, rParen]
);

var exp = memo $ eta (
  fun binop(op) {
    [s(op), fun (l, op, r) { Binop(op, l, r) }]
  }

  expr(
    {
      [Left, map(binop, { "!!" })],
      [Left, map(binop, { "&&" })],
      [Nona, map(binop, { "<", "<=", ">", ">=", "==", "!=" })],
      [Left, map(binop, { "+", "-" })],
      [Left, map(binop, { "*", "/", "%" })]
    },
    primary
  )
);

var stmt = memo $ eta syntax (
  kSkip                                      { Skip }       |
  kRead name = inbr[lParen, lident, rParen]  { Read(name) } |
  kWrite exp = inbr[lParen, exp, rParen]     { Write(exp) } |
  name = lident -s[":="] value = exp         { Assn(name, value) }
);

var stmt_seq = memo $ eta syntax (
  l = stmt_seq -s[";"] r = stmt { Seq(l, r) } |
  stmt
);

-- Public top-level parser
public parse = stmt_seq;
