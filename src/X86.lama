-- X86 codegeneration interface
-- We use stack machine programs as intermediate representation
import Fun;
import Data;
import Collection;
import List;
import Manifest;
import Buffer;

-- Assembler language interface
-- The registers: 
public regs = ["%ebx", "%ecx", "%esi", "%edi", "%eax", "%edx", "%ebp", "%esp"];

-- We can not freely operate with all register; only with 4 by now
public nRegs = regs.length - 5;

-- For convenience we define the following synonyms for the registers: 
public ebx = R(0),
    ecx = R(1),
    esi = R(2),
    edi = R(3),
    eax = R(4),
    edx = R(5),
    ebp = R(6),
    esp = R(7);

-- We need to know the word size to calculate offsets correctly
public wordSize = 4;

-- We need to distinguish the following operand types: 
--    R (int)       -- hard register
--    S (int)       -- a position on the hardware stack
--    M (string)    -- a named memory location
--    L (int)       -- an immediate operand
--    I (int, opnd) -- an indirect operand with offset

-- Some x86 instruction (we do not need all of them):
--   Mov   (opnd, opnd)         -- copies a value from the first to the second operand  
--   Lea   (opnd, opnd)         -- loads an address of the first operand into the second
--   Binop (string, opnd, opnd) -- makes a binary operation; note, the first operand
--                                 designates x86 operator, not the source language one
--   IDiv  (opnd)               -- x86 integer division, see instruction set reference 
--   Cltd                       -- see instruction set reference           
--   Set   (string, string)     -- sets a value from flags; the first operand is the   
--                                 suffix, which determines the value being set, the
--                                 the second --- (sub)register name
--   Jmp   (string)             -- unconditional jump to a label
--   CJmp  (string, string)     -- conditional jump to a label
--   Label (string)             -- a label
--   Push  (opnd)               -- pushes the operand on the hardware stack
--   Pop   (opnd)               -- pops from the hardware stack to the operand
--   Call  (string)             -- calls a function by its name 
--   Ret                        -- returns from a function
--   Meta  (string)             -- metainformation (declarations, etc.)

-- Machine instruction printer
public fun insnString(insn) {

  fun binopString(op) {
    case op of
        "+"   -> "addl"
      | "-"   -> "subl"
      | "*"   -> "imull"
      | "&&"  -> "andl"
      | "!!"  -> "orl"
      | "^"   -> "xorl"
      | "cmp" -> "cmpl"
    esac
  }

  fun opndString(opnd) {
    case opnd of
        R (i)    -> regs [i]
      | S (i)    ->
        if i >= 0
          then sprintf("-%d(%%ebp)", (i + 1) * wordSize)
          else sprintf("%d(%%ebp)", 8 + (-1 - i) * wordSize)
        fi
      | M (x)    -> x
      | L (i)    -> sprintf("$%d", i)
      | I (0, x) -> sprintf("(%s)", opndString(x))
      | I (n, x) -> sprintf("%d(%s)", n, opndString(x))
    esac
  }

  case insn of
      Cltd               -> "\tcltd\n"
    | Set   (suf, s)     -> sprintf("\tset%s\t%s\n", suf, s)
    | IDiv  (s1)         -> sprintf("\tidivl\t%s\n", opndString(s1))
    | Binop (op, s1, s2) -> sprintf("\t%s\t%s,\t%s\n", binopString(op), opndString(s1), opndString(s2))
    | Lea   (s1, s2)     -> sprintf("\tleal\t%s,\t%s\n", opndString(s1), opndString(s2))
    | Mov   (s1, s2)     -> sprintf("\tmovl\t%s,\t%s\n", opndString(s1), opndString(s2))
    | Push  (s)          -> sprintf("\tpushl\t%s\n", opndString(s))
    | Pop   (s)          -> sprintf("\tpopl\t%s\n", opndString(s))
    | Ret                -> "\tret\n"
    | Call  (p)          -> sprintf("\tcall\t%s\n", p)
    | Label (l)          -> sprintf("%s:\n", l)
    | Jmp   (l)          -> sprintf("\tjmp\t%s\n", l)
    | CJmp  (c, l)       -> sprintf("\tj%s\t%s\n", c, l)
    | Meta  (m)          -> m
  esac
}

-- Environment for symbolic interpreter
-- An environment holds
--    a symbolic stack
--    a maximal stack depth reached so far
--    a set of global variable names
--    a barrier condition (set up right after an unconditional jump is interpreter)
--    a stack map which maps labels to symbolic stacks

public fun makeEnv(stack, stackSlots, globals, barrier, stackMap, fLabel, nLocals) {
  -- Returns an internal name for a global variable
  fun globalName(name) {
    "global_" ++ name
  }

  -- Returns a string representation of the environment
  fun envString() {
    sprintf("Stack     : %s\nStackSlots: %d\nGlobals   : %s\n", stack.string, stackSlots, elements(globals).string)
  }

  -- Allocates a new position on the symbolic stack;
  -- returns a pair: a location for allocated item and
  -- an updated environment
  fun allocate() {
    case
      case stack of
        { }         -> [ebx, 0]
        | S (n) : _ -> [S(n + 1), n + 2]
        | R (n) : _ -> if n < nRegs then [R(n + 1), stackSlots] else [S(nLocals), nLocals + 1] fi
        | _         -> [S(nLocals), nLocals + 1]
      esac
    of [x, n] -> [x, makeEnv(x:stack, if n > stackSlots then n else stackSlots fi, globals, barrier, stackMap, fLabel, nLocals)]esac
  }

  -- Pushes an item on the symbolic state; returns an updated envirtonment
  fun push(y) {
    makeEnv(y:stack, stackSlots, globals, barrier, stackMap, fLabel, nLocals)
  }

  -- Pops one item from the symbolic stack; returns a pair: a popped
  -- item and an updated environment
  fun pop() {
    case stack of
      x : stack -> [x, makeEnv(stack, stackSlots, globals, barrier, stackMap, fLabel, nLocals)]
    esac
  }

  -- Pops two items from the symbolic stack; returns a triple:
  -- popped items and an undated environment
  fun pop2() {
    case stack of
      x : y : stack -> [x, y, makeEnv(stack, stackSlots, globals, barrier, stackMap, fLabel, nLocals)]
    esac
  }

  -- Peeks the top of the symbolic stack
  fun peek() {
    stack.fst
  }

  -- Adds a global variable; returns an updated environment
  fun addGlobal(name) {
    makeEnv(stack, stackSlots, addSet(globals, globalName(name)), barrier, stackMap, fLabel, nLocals)
  }

  -- References an allocation
  fun loc(alloc) {
    case alloc of
        Glb (x) -> M(globalName(x))
      | Arg (i) -> S(-1 - i)
      | Loc (i) -> S(i)
    esac
  }

  -- Gets a list of global variables from the environment
  fun getGlobals() {
    globals.elements
  }

  -- Gets a maximal stack size from the environment
  fun getStackSize() {
    stackSlots
  }

  -- Gets barrier condition
  fun isBarrier() {
    barrier
  }

  -- Sets barrier condition
  fun setBarrier() {
    makeEnv(stack, stackSlots, globals, true, stackMap, fLabel, nLocals)
  }

  -- Associates the current symbolic state with a label
  fun setStack(l) {
    makeEnv(stack, stackSlots, globals, false, addMap(stackMap, l, stack), fLabel, nLocals)
  }

  -- Retrieves a stack for a label
  fun retrieveStack(l) {
    case findMap(stackMap, l) of
        None         -> makeEnv(stack, stackSlots, globals, false, stackMap, fLabel, nLocals)
      | Some (stack) -> makeEnv(stack, stackSlots, globals, false, stackMap, fLabel, nLocals)
    esac
  }

  -- Sets the label of current function
  fun enterFunction(fLabel, nl) {
    makeEnv(stack, stackSlots, globals, false, stackMap, fLabel, nl)
  }

  -- Gets the label of current function
  fun currentFunction() {
    fLabel
  }

  -- Gets the list of live registers past given symbolic stack depth
  fun liveRegisters(depth) {
    fun inner(d, acc, st) {
      case st of
        {}               -> acc
        | (r@R (_)) : tl -> inner(d + 1, if d >= depth then r:acc else acc fi, tl)
        | _ : tl         -> inner(d + 1, acc, tl)
      esac
    }

    inner(0, {}, stack)
  }

  -- Gets a local static size for the current function
  fun staticSize() {
    nLocals + stackSlots
  }

  [
    envString,
    allocate,
    push,
    pop,
    pop2,
    addGlobal,
    loc,
    getGlobals,
    getStackSize,
    peek,
    isBarrier,
    setBarrier,
    setStack,
    retrieveStack,
    enterFunction,
    currentFunction,
    liveRegisters,
    staticSize
  ]
}

-- Exported accessors
public fun envString(env) {
  env[0]()
}

public fun allocate(env) {
  env[1]()
}

public fun push(env, x) {
  env[2](x)
}

public fun pop(env) {
  env[3]()
}

public fun pop2(env) {
  env[4]()
}

public fun addGlobal(env, name) {
  env[5](name)
}

public fun locc(env, name) {
  env[6](name)
}

public fun getGlobals(env) {
  env[7]()
}

public fun getStackSize(env) {
  env[8]()
}

public fun peek(env) {
  env[9]()
}

public fun isBarrier(env) {
  env[10]()
}

public fun setBarrier(env) {
  env[11]()
}

public fun setStack(env, l) {
  env[12](l)
}

public fun retrieveStack(env, l) {
  env[13](l)
}

public fun enterFunctionn(env, fLabel, nL) {
  env[14](fLabel, nL)
}

public fun currentFunction(env) {
  env[15]()
}

public fun liveRegisters(env, depth) {
  env[16](depth)
}

public fun staticSize(env) {
  env[17]()
}

-- Creates an initial environment
public fun initEnv() {
  makeEnv(0, emptySet(compare), emptySet(compare), false, emptyMap(compare), "", 0)
}

-- Codegeneration helper functions
-- Generates code section
public fun codeSection(text) {
  singletonBuffer(Meta("\t.text\n")) <+> text
}

-- Generates data section
public fun dataSection(text) {
  singletonBuffer(Meta("\t.data\n")) <+> text
}

-- Generates data definition
public fun dataDef(name) {
  Meta(sprintf("%s:\t.int\t0\n", name))
}

-- Generates function prologue
public fun prologue(fLabel) {
  singletonBuffer(Push(ebp)) <+
    Mov(esp, ebp) <+
    Binop("-", M(sprintf("$%s_SIZE", fLabel)), esp)
}

-- Generates function epilogue
public fun epilogue(env) {
  var metaDef = Meta(sprintf("\t.set\t%s_SIZE,\t%d\n", env.currentFunction, env.staticSize * wordSize));

  if compare(env.currentFunction, "main") == 0
    then [env, singletonBuffer(Mov(ebp, esp)) <+ Pop(ebp) <+ Binop("^", eax, eax) <+ Ret <+ metaDef]
    else case env.pop of
      [y, env] -> [env, singletonBuffer(Mov(y, eax)) <+ Mov(ebp, esp) <+ Pop(ebp) <+ Ret <+ metaDef]
    esac
  fi
}

-- Checks if an operand resides on a stack
public fun stackOpnd(opnd) {
  case opnd of
    S (_) -> true
    | _   -> false
  esac
}

-- Checks if an operand resides in memory
public fun memOpnd(opnd) {
  case opnd of
      S (_) -> true
    | M (_) -> true
    | _     -> false
  esac
}

-- Generates a move between locations, using
-- intermediate register if needed
public fun move(from, to) {
  if memOpnd(from) && memOpnd(to)
    then singletonBuffer(Mov(from, eax)) <+ Mov(eax, to)
    else singletonBuffer(Mov(from, to))
  fi
}

-- Gets a suffix for Set instruction from
-- source language comparison operator
public fun suffix(op) {
  case op of
      "<"  -> "l"
    | "<=" -> "le"
    | "==" -> "e"
    | "!=" -> "ne"
    | ">=" -> "ge"
    | ">"  -> "g"
  esac
}

public fun addressMov(from, toAddress) {
  var movedFrom =
    case from of
      R (_) -> [emptyBuffer(), from]
      | _   -> [Mov(from, eax).singletonBuffer, eax]
    esac;

  var movedAddress =
    case toAddress of
      R (_) -> [emptyBuffer(), toAddress]
      | _   -> [Mov(from, edx).singletonBuffer, edx]
    esac;

  movedFrom[0] <+> movedAddress[0] <+ Mov(movedFrom[1], I(0, movedAddress[1]))
}
